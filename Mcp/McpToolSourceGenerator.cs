using System.Text;
using IdasCli.Mcp;

namespace IdasCli.Tools;

/// <summary>
/// Generates C# source code for MCP tool wrappers from Cocona commands
/// </summary>
public class McpToolSourceGenerator
{
    public static string GenerateToolsSourceCode()
    {
        // First, scan all tools
        McpToolRegistrar.ScanAndRegisterTools();
        
        var sb = new StringBuilder();
        
        // Add file header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// This file is automatically generated by McpToolSourceGenerator");
        sb.AppendLine("// DO NOT EDIT MANUALLY");
        sb.AppendLine();
        sb.AppendLine("#nullable disable");
        sb.AppendLine();
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using ModelContextProtocol.Server;");
        sb.AppendLine();
        sb.AppendLine("namespace IdasCli.Mcp;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated MCP tools from Cocona commands");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[McpServerToolType]");
        sb.AppendLine("public class AutoGeneratedMcpTools : CommandsBase");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly DynamicCoconaTool _executor;");
        sb.AppendLine();
        sb.AppendLine("    public AutoGeneratedMcpTools()");
        sb.AppendLine("    {");
        sb.AppendLine("        _executor = new DynamicCoconaTool(null!);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate a method for each tool
        foreach (var tool in McpToolRegistrar.GetAllTools())
        {
            GenerateToolMethod(sb, tool);
        }

        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GenerateToolMethod(StringBuilder sb, CoconaToolMetadata tool)
    {
        // Add method documentation
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// {EscapeXmlComment(tool.Description)}");
        sb.AppendLine("    /// </summary>");
        
        // Add MCP tool attribute
        sb.AppendLine($"    [McpServerTool(Name = \"{tool.ToolName}\")]");
        sb.AppendLine($"    [Description(\"{EscapeString(tool.Description)}\")]");
        
        // Generate method signature
        sb.Append("    public async Task<object> ");
        sb.Append(ToPascalCase(tool.CommandName));
        sb.Append(ToPascalCase(tool.SubCommandName));
        sb.Append("(");
        
        // Generate parameters
        var paramList = new List<string>();
        
        // First add required parameters, then optional ones (C# requirement)
        var sortedParams = tool.Parameters
            .OrderBy(p => p.IsOptional ? 1 : 0)
            .ThenBy(p => p.Name)
            .ToList();
        
        foreach (var param in sortedParams)
        {
            var paramDecl = new StringBuilder();
            paramDecl.Append($"\n        [Description(\"{EscapeString(param.Description)}\")] ");
            paramDecl.Append(GetCSharpTypeName(param.Type, param.IsOptional));
            paramDecl.Append(" ");
            paramDecl.Append(param.Name);
            
            if (param.IsOptional)
            {
                paramDecl.Append(" = ");
                paramDecl.Append(GetDefaultValueString(param));
            }
            
            paramList.Add(paramDecl.ToString());
        }
        
        if (paramList.Any())
        {
            sb.Append(string.Join(",", paramList));
            sb.Append("\n    ");
        }
        
        sb.AppendLine(")");
        sb.AppendLine("    {");
        
        // Method body
        sb.AppendLine("        var parameters = new Dictionary<string, object?>");
        sb.AppendLine("        {");
        
        foreach (var param in tool.Parameters)
        {
            sb.AppendLine($"            {{ \"{param.Name}\", {param.Name} }},");
        }
        
        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine($"        return await _executor.InvokeCommand(\"{tool.ToolName}\", parameters);");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string GetCSharpTypeName(Type type, bool isOptional)
    {
        var baseType = Nullable.GetUnderlyingType(type) ?? type;
        
        string typeName = baseType.Name switch
        {
            "String" => "string",
            "Int32" => "int",
            "Int64" => "long",
            "Boolean" => "bool",
            "Guid" => "Guid",
            "DateTime" => "DateTime",
            _ => baseType.Name
        };
        
        // Only add ? for value types when optional (since we're using #nullable disable)
        if (isOptional && baseType.IsValueType)
        {
            return $"{typeName}?";
        }
        
        return typeName;
    }

    private static string GetDefaultValueString(CoconaParameterMetadata param)
    {
        if (param.DefaultValue == null || param.DefaultValue == DBNull.Value)
        {
            return "null";
        }

        if (param.Type == typeof(string))
        {
            return $"\"{EscapeString(param.DefaultValue.ToString() ?? "")}\"";
        }

        if (param.Type == typeof(bool))
        {
            return param.DefaultValue.ToString()!.ToLower();
        }

        return param.DefaultValue.ToString() ?? "null";
    }

    private static string ToPascalCase(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        var parts = input.Split(new[] { '-', '_' }, StringSplitOptions.RemoveEmptyEntries);
        var sb = new StringBuilder();
        
        foreach (var part in parts)
        {
            if (part.Length > 0)
            {
                sb.Append(char.ToUpper(part[0]));
                sb.Append(part.Substring(1));
            }
        }
        
        return sb.ToString();
    }

    private static string EscapeString(string input)
    {
        return input.Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r");
    }

    private static string EscapeXmlComment(string input)
    {
        return input.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
    }

    /// <summary>
    /// Generates the source code and writes it to a file
    /// </summary>
    public static async Task GenerateAndSaveAsync(string outputPath = "Mcp/AutoGeneratedMcpTools.cs")
    {
        var sourceCode = GenerateToolsSourceCode();
        
        // Ensure directory exists
        var directory = Path.GetDirectoryName(outputPath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }
        
        await File.WriteAllTextAsync(outputPath, sourceCode);
        Console.WriteLine($"Generated MCP tools source code: {outputPath}");
        Console.WriteLine($"Total tools generated: {McpToolRegistrar.GetAllTools().Count()}");
    }
}
